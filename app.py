from slack_bolt import App
from slack_bolt.adapter.socket_mode import SocketModeHandler
import os
import logging
import json
import threading
import time
from dotenv import load_dotenv

from clementine.config.logging import LoggingConfigurator
from clementine import TangerineClient, ClementineBot, SlackClient, PromptLoader
from clementine.formatters import MessageFormatter, BlockKitFormatter
from clementine.feedback_client import FeedbackClient
from clementine.feedback_handler import FeedbackHandler
from clementine.room_config_repository import RoomConfigRepository
from clementine.room_config_service import RoomConfigService
from clementine.config_modal_handler import ConfigModalHandler
from clementine.slack_context_extractor import SlackContextExtractor
from clementine.advanced_chat_client import AdvancedChatClient
from clementine.slack_question_bot import SlackQuestionBot

load_dotenv()

# Configure logging
configurator = LoggingConfigurator(
    level_name=os.getenv("LOG_LEVEL", "INFO"),
    format_string=os.getenv("LOG_FORMAT", "%(asctime)s - %(name)s - %(levelname)s - %(message)s"),
    log_file=os.getenv("LOG_FILE")
)
logger = configurator.configure(__name__)

# Enable debug logging for feedback components
logging.getLogger("clementine.feedback_handler").setLevel(logging.DEBUG)
logging.getLogger("clementine.slack_client").setLevel(logging.DEBUG)

# Validate required environment variables
def validate_required_env_vars():
    """Validate all required environment variables are set."""
    required_vars = {
        "SLACK_BOT_TOKEN": "Slack bot token (xoxb-...)",
        "SLACK_SIGNING_SECRET": "Slack signing secret",
        "SLACK_APP_TOKEN": "Slack app token (xapp-...)",
        "TANGERINE_API_URL": "Tangerine API base URL",
        "TANGERINE_API_TOKEN": "Tangerine API authentication token"
    }
    
    missing_vars = []
    for var, description in required_vars.items():
        if not os.getenv(var):
            missing_vars.append(f"  {var}: {description}")
    
    if missing_vars:
        error_msg = "Missing required environment variables:\n" + "\n".join(missing_vars)
        logger.error(error_msg)
        raise SystemExit(f"Configuration Error: {error_msg}")

validate_required_env_vars()

# Load prompts from files at startup
logger.info("Loading prompts from files")
prompt_loader = PromptLoader()
try:
    prompts = prompt_loader.load_prompts()
    logger.info("Successfully loaded prompts")
except Exception as e:
    logger.error("Failed to load prompts: %s", e)
    raise SystemExit(f"Prompt Loading Error: {e}")

# Load config from environment
SLACK_BOT_TOKEN = os.getenv("SLACK_BOT_TOKEN")  # xoxb-...
SLACK_SIGNING_SECRET = os.getenv("SLACK_SIGNING_SECRET")
SLACK_APP_TOKEN = os.getenv("SLACK_APP_TOKEN")  # xapp-...

BOT_NAME = os.getenv("BOT_NAME", "Clementine")

# Validate and clean assistant list
assistant_list_raw = os.getenv("ASSISTANT_LIST", "konflux")
ASSISTANT_LIST = [a.strip() for a in assistant_list_raw.split(",") if a.strip()]
if not ASSISTANT_LIST:
    logger.warning("No valid assistants in ASSISTANT_LIST, using default: konflux")
    ASSISTANT_LIST = ["konflux"]

# Use loaded system prompt as default, with environment variable override
DEFAULT_PROMPT = os.getenv("DEFAULT_PROMPT", prompts.system_prompt)
TANGERINE_API_URL = os.getenv("TANGERINE_API_URL", "").rstrip('/')  # Remove trailing slash
TANGERINE_API_TOKEN = os.getenv("TANGERINE_API_TOKEN")

# Import configuration functions
from clementine.app_config import get_timeout_value, get_model_override

TANGERINE_API_TIMEOUT = get_timeout_value()
logger.info("Using Tangerine API timeout: %d seconds", TANGERINE_API_TIMEOUT)

# Model Override Configuration
MODEL_OVERRIDE = get_model_override()
if MODEL_OVERRIDE:
    logger.info("Model override configured: %s", MODEL_OVERRIDE)
else:
    logger.info("No model override configured - using Tangerine API default")

# Room Configuration Database
ROOM_CONFIG_DB_PATH = os.getenv("ROOM_CONFIG_DB_PATH", "room_configs.db")
logger.info("Using room configuration database path: %s", ROOM_CONFIG_DB_PATH)

# Import configuration functions
from clementine.app_config import get_slack_context_limits

SLACK_MIN_CONTEXT, SLACK_MAX_CONTEXT = get_slack_context_limits()
logger.info("Using Slack context limits: min=%d, max=%d", SLACK_MIN_CONTEXT, SLACK_MAX_CONTEXT)

# AI Disclosure Configuration
AI_DISCLOSURE_ENABLED = os.getenv("AI_DISCLOSURE_ENABLED", "true").lower() == "true"
AI_DISCLOSURE_TEXT = os.getenv("AI_DISCLOSURE_TEXT", "This response was generated by AI. Please verify important information.")

logger.info("AI disclosure enabled: %s", AI_DISCLOSURE_ENABLED)

# Feedback Configuration
FEEDBACK_ENABLED = os.getenv("FEEDBACK_ENABLED", "true").lower() == "true"
logger.info("User feedback enabled: %s", FEEDBACK_ENABLED)

# Initialize the Slack app
logger.info("Initializing Slack app")
app = App(token=SLACK_BOT_TOKEN, signing_secret=SLACK_SIGNING_SECRET)

# Initialize the bot components
logger.info("Initializing bot components")
tangerine_client = TangerineClient(
    api_url=TANGERINE_API_URL,
    api_token=TANGERINE_API_TOKEN,
    timeout=TANGERINE_API_TIMEOUT,
    model_override=MODEL_OVERRIDE
)

slack_client = SlackClient(app.client)

# Initialize room configuration components
logger.info("Initializing room configuration components")
room_config_repository = RoomConfigRepository(db_path=ROOM_CONFIG_DB_PATH)
room_config_service = RoomConfigService(
    repository=room_config_repository,
    default_assistants=ASSISTANT_LIST,
    default_prompt=DEFAULT_PROMPT,
    default_slack_context=SLACK_MIN_CONTEXT,
    slack_min_context=SLACK_MIN_CONTEXT,
    slack_max_context=SLACK_MAX_CONTEXT
)
config_modal_handler = ConfigModalHandler(room_config_service, slack_client, tangerine_client)

# Initialize feedback components if enabled
if FEEDBACK_ENABLED:
    feedback_client = FeedbackClient(
        api_url=TANGERINE_API_URL,
        api_token=TANGERINE_API_TOKEN
    )
    feedback_handler = FeedbackHandler(feedback_client, slack_client)
    logger.info("Feedback client and handler initialized")
else:
    feedback_handler = None
    logger.info("Feedback disabled - skipping feedback component initialization")

# Choose formatter based on AI disclosure configuration
if AI_DISCLOSURE_ENABLED:
    formatter = BlockKitFormatter(
        ai_disclosure_enabled=AI_DISCLOSURE_ENABLED,
        ai_disclosure_text=AI_DISCLOSURE_TEXT,
        feedback_enabled=FEEDBACK_ENABLED
    )
    logger.info("Using Block Kit formatter with AI disclosure and feedback: %s", FEEDBACK_ENABLED)
else:
    formatter = MessageFormatter()
    logger.info("Using plain text formatter (feedback not available with plain text)")

clementine_bot = ClementineBot(
    tangerine_client=tangerine_client,
    slack_client=slack_client,
    bot_name=BOT_NAME,
    assistant_list=ASSISTANT_LIST,
    default_prompt=DEFAULT_PROMPT,
    formatter=formatter,
    room_config_service=room_config_service
)

# Initialize Slack question components
logger.info("Initializing Slack question components")
slack_context_extractor = SlackContextExtractor(app.client)
advanced_chat_client = AdvancedChatClient(
    api_url=TANGERINE_API_URL,
    api_token=TANGERINE_API_TOKEN,
    timeout=TANGERINE_API_TIMEOUT,
    model_override=MODEL_OVERRIDE
)
slack_question_bot = SlackQuestionBot(
    slack_client=slack_client,
    context_extractor=slack_context_extractor,
    advanced_chat_client=advanced_chat_client,
    bot_name=BOT_NAME,
    room_config_service=room_config_service,
    user_prompt=prompts.user_prompt,
    system_prompt=prompts.slack_analysis_system_prompt,
    formatter=formatter
)

logger.info("Bot '%s' initialized with assistants: %s", BOT_NAME, ASSISTANT_LIST)

# Health check file path
HEALTH_FILE_PATH = "/tmp/health"

def update_health_file():
    """Update the health file periodically to indicate the application is running."""
    while True:
        try:
            with open(HEALTH_FILE_PATH, 'w') as f:
                f.write(str(int(time.time())))
            logger.debug("Health file updated")
        except Exception as e:
            logger.warning("Failed to update health file: %s", e)
        time.sleep(30)  # Update every 30 seconds

# Start health check thread
health_thread = threading.Thread(target=update_health_file, daemon=True)
health_thread.start()
logger.info("Health check thread started")

@app.event("app_mention")
def handle_mention(event, say, client):
    """Handle app mentions by delegating to the ClementineBot."""
    logger.debug("Received app mention from user %s in channel %s", 
                event.get('user'), event.get('channel'))
    clementine_bot.handle_mention(event, client)

@app.action("feedback_like")
@app.action("feedback_dislike")
def handle_feedback_button(ack, body, respond):
    """Handle feedback button interactions."""
    # Immediately show "Sending feedback..." by updating the message
    try:
        if FEEDBACK_ENABLED and feedback_handler:
            logger.debug("Received feedback button interaction from user %s", 
                        body.get('user', {}).get('id', 'unknown'))
            
            # Show immediate "Sending feedback..." response
            feedback_handler.show_sending_feedback_message(body, respond)
            ack()  # Acknowledge the interaction
            
            # Process feedback in background
            feedback_handler.handle_feedback_button_async(body, respond)
        else:
            ack()
            logger.warning("Received feedback button interaction but feedback is disabled")
    except Exception as e:
        ack()
        logger.error("Error in feedback button handler: %s", e)

@app.command("/clementine")
def handle_clementine_command(ack, body, client):
    """Handle /clementine slash command."""
    ack()  # Acknowledge the command immediately
    
    try:
        # Extract command arguments
        text = body.get("text", "").strip()
        
        if text == "config":
            # Handle configuration command
            channel_id = body.get("channel_id")
            trigger_id = body.get("trigger_id")
            
            if not channel_id or not trigger_id:
                logger.error("Missing channel_id or trigger_id in slash command")
                return
            
            logger.info("Opening config modal for channel %s", channel_id)
            success = config_modal_handler.create_config_modal(channel_id, trigger_id)
            
            if not success:
                # Send error message to user
                client.chat_postEphemeral(
                    channel=channel_id,
                    user=body.get("user_id"),
                    text="❌ Sorry, I couldn't open the configuration modal. Please try again."
                )
        elif text.startswith("slack "):
            # Handle slack context question command
            question = text[6:].strip()  # Remove "slack " prefix
            
            if not question:
                client.chat_postEphemeral(
                    channel=body.get("channel_id"),
                    user=body.get("user_id"),
                    text="❌ Please provide a question. Example: `/clementine slack what are andrew and psav talking about re: cloweder`"
                )
                return
            
            channel_id = body.get("channel_id")
            user_id = body.get("user_id")
            
            # For slash commands, there's no thread context, so we'll use channel history
            slack_question_bot.handle_question(
                question=question,
                channel=channel_id,
                thread_ts=None,  # No thread for slash commands
                user_id=user_id,
                slack_web_client=client
            )
        else:
            # Show help text for unknown commands
            client.chat_postEphemeral(
                channel=body.get("channel_id"),
                user=body.get("user_id"),
                text=f"Available commands:\n• `/clementine config` - Configure room settings\n• `/clementine slack <question>` - Ask questions about channel context\n\nUnknown command: `{text}`"
            )
            
    except Exception as e:
        logger.error("Error handling slash command: %s", e)
        try:
            client.chat_postEphemeral(
                channel=body.get("channel_id"),
                user=body.get("user_id"),
                text="❌ An error occurred processing your command. Please try again."
            )
        except Exception:
            logger.error("Failed to send error message to user")

@app.view("room_config_modal")
def handle_config_modal_submission(ack, body, client):
    """Handle configuration modal submission."""
    try:
        # Handle the modal submission
        response = config_modal_handler.handle_modal_submission(body)
        ack(response)
        
        # If successful, send confirmation message
        if response.get("response_action") == "clear":
            # Extract room info for confirmation
            private_metadata = body["view"]["private_metadata"]
            metadata = json.loads(private_metadata)
            room_id = metadata["room_id"]
            
            client.chat_postEphemeral(
                channel=room_id,
                user=body["user"]["id"],
                text="✅ Room configuration saved successfully!"
            )
            
    except Exception as e:
        logger.error("Error handling config modal submission: %s", e)
        ack({
            "response_action": "errors",
            "errors": {
                "general": "An unexpected error occurred. Please try again."
            }
        })

# Start the app using Socket Mode
if __name__ == "__main__":
    logger.info("Starting %s bot in Socket Mode", BOT_NAME)
    try:
        SocketModeHandler(app, SLACK_APP_TOKEN).start()
    except KeyboardInterrupt:
        logger.info("Bot shutdown requested by user")
    except Exception as e:
        logger.exception("Fatal error starting bot: %s", e)
        raise