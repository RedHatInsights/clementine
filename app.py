from slack_bolt import App
from slack_bolt.adapter.socket_mode import SocketModeHandler
import os
import logging
import json
from dotenv import load_dotenv

from clementine.config.logging import LoggingConfigurator
from clementine import TangerineClient, ClementineBot, SlackClient
from clementine.formatters import MessageFormatter, BlockKitFormatter
from clementine.feedback_client import FeedbackClient
from clementine.feedback_handler import FeedbackHandler
from clementine.room_config_repository import RoomConfigRepository
from clementine.room_config_service import RoomConfigService
from clementine.config_modal_handler import ConfigModalHandler

load_dotenv()

# Configure logging
configurator = LoggingConfigurator(
    level_name=os.getenv("LOG_LEVEL", "INFO"),
    format_string=os.getenv("LOG_FORMAT", "%(asctime)s - %(name)s - %(levelname)s - %(message)s"),
    log_file=os.getenv("LOG_FILE")
)
logger = configurator.configure(__name__)

# Enable debug logging for feedback components
logging.getLogger("clementine.feedback_handler").setLevel(logging.DEBUG)
logging.getLogger("clementine.slack_client").setLevel(logging.DEBUG)

# Validate required environment variables
def validate_required_env_vars():
    """Validate all required environment variables are set."""
    required_vars = {
        "SLACK_BOT_TOKEN": "Slack bot token (xoxb-...)",
        "SLACK_SIGNING_SECRET": "Slack signing secret",
        "SLACK_APP_TOKEN": "Slack app token (xapp-...)",
        "TANGERINE_API_URL": "Tangerine API base URL",
        "TANGERINE_API_TOKEN": "Tangerine API authentication token"
    }
    
    missing_vars = []
    for var, description in required_vars.items():
        if not os.getenv(var):
            missing_vars.append(f"  {var}: {description}")
    
    if missing_vars:
        error_msg = "Missing required environment variables:\n" + "\n".join(missing_vars)
        logger.error(error_msg)
        raise SystemExit(f"Configuration Error: {error_msg}")

validate_required_env_vars()

# Load config from environment
SLACK_BOT_TOKEN = os.getenv("SLACK_BOT_TOKEN")  # xoxb-...
SLACK_SIGNING_SECRET = os.getenv("SLACK_SIGNING_SECRET")
SLACK_APP_TOKEN = os.getenv("SLACK_APP_TOKEN")  # xapp-...

BOT_NAME = os.getenv("BOT_NAME", "Clementine")

# Validate and clean assistant list
assistant_list_raw = os.getenv("ASSISTANT_LIST", "konflux")
ASSISTANT_LIST = [a.strip() for a in assistant_list_raw.split(",") if a.strip()]
if not ASSISTANT_LIST:
    logger.warning("No valid assistants in ASSISTANT_LIST, using default: konflux")
    ASSISTANT_LIST = ["konflux"]

DEFAULT_PROMPT = os.getenv("DEFAULT_PROMPT", "You are a helpful assistant.")
TANGERINE_API_URL = os.getenv("TANGERINE_API_URL", "").rstrip('/')  # Remove trailing slash
TANGERINE_API_TOKEN = os.getenv("TANGERINE_API_TOKEN")

# Validate timeout value with proper error handling
def get_timeout_value() -> int:
    """Get and validate the API timeout value from environment."""
    timeout_str = os.getenv("TANGERINE_API_TIMEOUT", "500")
    try:
        timeout_value = int(timeout_str)
        if timeout_value <= 0:
            logger.warning("Invalid timeout value %d, must be positive. Using default 500.", timeout_value)
            return 500
        if timeout_value > 3600:  # 1 hour max
            logger.warning("Timeout value %d too large, capping at 3600 seconds.", timeout_value)
            return 3600
        return timeout_value
    except ValueError:
        logger.error("Invalid timeout value '%s', must be a number. Using default 500.", timeout_str)
        return 500

TANGERINE_API_TIMEOUT = get_timeout_value()
logger.info("Using Tangerine API timeout: %d seconds", TANGERINE_API_TIMEOUT)

# Room Configuration Database
ROOM_CONFIG_DB_PATH = os.getenv("ROOM_CONFIG_DB_PATH", "room_configs.db")
logger.info("Using room configuration database path: %s", ROOM_CONFIG_DB_PATH)

# AI Disclosure Configuration
AI_DISCLOSURE_ENABLED = os.getenv("AI_DISCLOSURE_ENABLED", "true").lower() == "true"
AI_DISCLOSURE_TEXT = os.getenv("AI_DISCLOSURE_TEXT", "This response was generated by AI. Please verify important information.")

logger.info("AI disclosure enabled: %s", AI_DISCLOSURE_ENABLED)

# Feedback Configuration
FEEDBACK_ENABLED = os.getenv("FEEDBACK_ENABLED", "true").lower() == "true"
logger.info("User feedback enabled: %s", FEEDBACK_ENABLED)

# Initialize the Slack app
logger.info("Initializing Slack app")
app = App(token=SLACK_BOT_TOKEN, signing_secret=SLACK_SIGNING_SECRET)

# Initialize the bot components
logger.info("Initializing bot components")
tangerine_client = TangerineClient(
    api_url=TANGERINE_API_URL,
    api_token=TANGERINE_API_TOKEN,
    timeout=TANGERINE_API_TIMEOUT
)

slack_client = SlackClient(app.client)

# Initialize room configuration components
logger.info("Initializing room configuration components")
room_config_repository = RoomConfigRepository(db_path=ROOM_CONFIG_DB_PATH)
room_config_service = RoomConfigService(
    repository=room_config_repository,
    default_assistants=ASSISTANT_LIST,
    default_prompt=DEFAULT_PROMPT
)
config_modal_handler = ConfigModalHandler(room_config_service, slack_client, tangerine_client)

# Initialize feedback components if enabled
if FEEDBACK_ENABLED:
    feedback_client = FeedbackClient(
        api_url=TANGERINE_API_URL,
        api_token=TANGERINE_API_TOKEN
    )
    feedback_handler = FeedbackHandler(feedback_client, slack_client)
    logger.info("Feedback client and handler initialized")
else:
    feedback_handler = None
    logger.info("Feedback disabled - skipping feedback component initialization")

# Choose formatter based on AI disclosure configuration
if AI_DISCLOSURE_ENABLED:
    formatter = BlockKitFormatter(
        ai_disclosure_enabled=AI_DISCLOSURE_ENABLED,
        ai_disclosure_text=AI_DISCLOSURE_TEXT,
        feedback_enabled=FEEDBACK_ENABLED
    )
    logger.info("Using Block Kit formatter with AI disclosure and feedback: %s", FEEDBACK_ENABLED)
else:
    formatter = MessageFormatter()
    logger.info("Using plain text formatter (feedback not available with plain text)")

clementine_bot = ClementineBot(
    tangerine_client=tangerine_client,
    slack_client=slack_client,
    bot_name=BOT_NAME,
    assistant_list=ASSISTANT_LIST,
    default_prompt=DEFAULT_PROMPT,
    formatter=formatter,
    room_config_service=room_config_service
)

logger.info("Bot '%s' initialized with assistants: %s", BOT_NAME, ASSISTANT_LIST)

@app.event("app_mention")
def handle_mention(event, say, client):
    """Handle app mentions by delegating to the ClementineBot."""
    logger.debug("Received app mention from user %s in channel %s", 
                event.get('user'), event.get('channel'))
    clementine_bot.handle_mention(event, client)

@app.action("feedback_like")
@app.action("feedback_dislike")
def handle_feedback_button(ack, body, respond):
    """Handle feedback button interactions."""
    # Immediately show "Sending feedback..." by updating the message
    try:
        if FEEDBACK_ENABLED and feedback_handler:
            logger.debug("Received feedback button interaction from user %s", 
                        body.get('user', {}).get('id', 'unknown'))
            
            # Show immediate "Sending feedback..." response
            feedback_handler.show_sending_feedback_message(body, respond)
            ack()  # Acknowledge the interaction
            
            # Process feedback in background
            feedback_handler.handle_feedback_button_async(body, respond)
        else:
            ack()
            logger.warning("Received feedback button interaction but feedback is disabled")
    except Exception as e:
        ack()
        logger.error("Error in feedback button handler: %s", e)

@app.command("/clementine")
def handle_clementine_command(ack, body, client):
    """Handle /clementine slash command."""
    ack()  # Acknowledge the command immediately
    
    try:
        # Extract command arguments
        text = body.get("text", "").strip()
        
        if text == "config":
            # Handle configuration command
            channel_id = body.get("channel_id")
            trigger_id = body.get("trigger_id")
            
            if not channel_id or not trigger_id:
                logger.error("Missing channel_id or trigger_id in slash command")
                return
            
            logger.info("Opening config modal for channel %s", channel_id)
            success = config_modal_handler.create_config_modal(channel_id, trigger_id)
            
            if not success:
                # Send error message to user
                client.chat_postEphemeral(
                    channel=channel_id,
                    user=body.get("user_id"),
                    text="❌ Sorry, I couldn't open the configuration modal. Please try again."
                )
        else:
            # Show help text for unknown commands
            client.chat_postEphemeral(
                channel=body.get("channel_id"),
                user=body.get("user_id"),
                text=f"Available commands:\n• `/clementine config` - Configure room settings\n\nUnknown command: `{text}`"
            )
            
    except Exception as e:
        logger.error("Error handling slash command: %s", e)
        try:
            client.chat_postEphemeral(
                channel=body.get("channel_id"),
                user=body.get("user_id"),
                text="❌ An error occurred processing your command. Please try again."
            )
        except Exception:
            logger.error("Failed to send error message to user")

@app.view("room_config_modal")
def handle_config_modal_submission(ack, body, client):
    """Handle configuration modal submission."""
    try:
        # Handle the modal submission
        response = config_modal_handler.handle_modal_submission(body)
        ack(response)
        
        # If successful, send confirmation message
        if response.get("response_action") == "clear":
            # Extract room info for confirmation
            private_metadata = body["view"]["private_metadata"]
            metadata = json.loads(private_metadata)
            room_id = metadata["room_id"]
            
            client.chat_postEphemeral(
                channel=room_id,
                user=body["user"]["id"],
                text="✅ Room configuration saved successfully!"
            )
            
    except Exception as e:
        logger.error("Error handling config modal submission: %s", e)
        ack({
            "response_action": "errors",
            "errors": {
                "general": "An unexpected error occurred. Please try again."
            }
        })

# Start the app using Socket Mode
if __name__ == "__main__":
    logger.info("Starting %s bot in Socket Mode", BOT_NAME)
    try:
        SocketModeHandler(app, SLACK_APP_TOKEN).start()
    except KeyboardInterrupt:
        logger.info("Bot shutdown requested by user")
    except Exception as e:
        logger.exception("Fatal error starting bot: %s", e)
        raise